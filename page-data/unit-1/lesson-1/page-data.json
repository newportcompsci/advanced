{"componentChunkName":"component---src-templates-lesson-template-js","path":"/unit-1/lesson-1","webpackCompilationHash":"d7b7fe3ae17a002f0432","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/unit-1/lesson-1\",\n  \"start\": \"2019-09-05T00:00:00.000Z\",\n  \"end\": \"2019-09-05T00:00:00.000Z\",\n  \"title\": \"Lesson 1.01 - Setting up Eclipse and Java\",\n  \"slides\": true\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = Layout;\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Writing a Java Program\"), mdx(\"p\", null, \"A program always starts with a main method in a class, for example: \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"public class HelloWorld {\\n    public static void main(String[] args) {\\n        System.out.println(\\\"Hello, world!\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"We can continue to make more complex programs by using constructs such as\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"static methods\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"for-loops\"), \", and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"arrays\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"public class AddThemUp {\\n    private static final int LENGTH = 10;\\n\\n    public static void main(String[] args) {\\n        int[] values = new int[LENGTH];\\n        fillSequentially(values);\\n        printArray(values);\\n    }\\n\\n    public static void fillSequentially(int[] numbers) {\\n        for (int i = 0; i < numbers.length; i++) {\\n            // We can do this because arrays are passed\\n            // by reference. \\n            numbers[i] = i + 1; \\n        }\\n    }\\n\\n    public static void printArray(int[] numbers) {\\n        for (int val : numbers) {\\n            System.out.print(val + \\\" \\\");\\n        }\\n        \\n        System.out.println();\\n    }\\n}\\n\")), mdx(\"p\", null, \"We expect the output to be: \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-raw\"\n  }), \"1 2 3 4 5 6 7 8 9 10\\n\")), mdx(\"p\", null, \"In this course we want to start moving away from using static methods and try to leverage\\nthe power of Object-Oriented Programming (OOP). Lets write an object that encapsulates\\nthe functionality above. \"), mdx(\"p\", null, \"In a new file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ArrayFiller.java\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"public class ArrayFiller {\\n    private int[] values;\\n\\n    public ArrayFiller(int initialSize) {\\n        this.values = new int[initialSize];\\n    }\\n\\n    public void fill() {\\n        for (int i = 0; i < this.values.length; i++) {\\n            this.values[i] = i + 1; \\n        }\\n    }\\n\\n    @Override\\n    public String toString() {\\n        String result = \\\"\\\";\\n\\n        for (int val : this.values) {\\n            result += (i + \\\" \\\");\\n        }\\n\\n        return result;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Our client code (main method) would then look like: \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"public static void main(String[] args) {\\n    ArrayFiller filler = new ArrayFiller(10);\\n    filler.fill();\\n    System.out.println(filler);\\n}\\n\")), mdx(\"p\", null, \"Now array filler keeps track of it's own state and the client code doesn't have to\\nworry about keeping track of so many arrays. We can also create more than one \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ArrayFiller\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"path":"/unit-1/lesson-1","start":"September 05, 2019","title":"Lesson 1.01 - Setting up Eclipse and Java","attachments":null,"slides":true}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}