---
path: /unit-1/lesson-3
start: 2019-09-09
end: 2019-09-09
title: "Lesson 1.03 - Basic Complexity Analysis"
slides: true
---
import Layout from "../../../components/mdxLayout"
export default Layout


## Example 1

```java
public static void mystery(int n) {
    System.out.println("Mystery!" + n); // This only runs once
}

public static void main(String[] args) {
    mystery(1000000);
}
```

> We say that this is a "constatnt time" algorithm, it runs one line of code no matter what the input is. 

## Example 2

```java
public static void mystery(int[] numbers) {
    for (int i = 0; i < numbers.length; i++) {
        System.out.println(numbers[i]); // 1,000,000 times
    }
}

public static void main(String[] args) {
    int[] values = new int[1000000]; // 1 time

    mystery(values)
}
```

> This runs 10 + 1 times or 11 total

> If the array was 1,000,000 elements then it would run 1,000,001 lines of code, in terms of any length array of size N
> we say this runs N + 1 times 


## Example 3

```java

public static void mystery(int[][] values) {
    for (int i = 0; i < values.length; i++) {
        for (int j = 0; j < values[i].length; j++) {
            System.out.print(values + " "); // 100 times
        }
        System.out.println(); // 10 times
    }
}

public static void main(String[] args) {
    int[][] values = new int[10][10]; // 1 time

    mystery(values);
}

```

> In total we "kind-of" execute 100 + 10 + 1 lines of code or 111 lines of code

> For a square matrix of size N x N we expect about N^2 + N + 1 lines of code to execute

## Asymptotic Analysis

In practice it becomes not very practical to write out the complicated expressions that describe 
an algorithm to each detail but we more or less estimate.

| Example   | N = 1 | N = 10 | N = 100 | N = 1,000,000 |
|-----------|-------|--------|---------|---------------|
|          1|      1|       1|        1|              1| 
|      N + 1|      2|      11|     101 |      1,000,001| 
|N^2 + N + 1|      3|     111|  10,101 |       A really big number...        | 

> As N gets really big it becomes kind of pointless to include the lower order terms. 
> So in practice we generally just take the largest contributor.

## Big-O Notation (Upper Bound)

Even though we dropped the lower order terms we still call this a "Worst Case."

Taking the examples from the previous slide this turns into:

| Example   | N = 1 | N = 10 | N = 100 | N = 1,000,000 |
|-----------|-------|--------|---------|---------------|
|       O(1)|      1|       1|        1|              1| 
|       O(N)|      1|      10|      100|            1e9| 
|     O(N^2)|      1|     100|      1e4|           1e18|

> **Fun Fact**: There exists other types of analysis such as Big-Theta and Big-Omega which 
> describe algorithms in terms of a "tight-bound" and a "best-case" [link][1]


[1]:https://www.geeksforgeeks.org/analysis-of-algorithms-set-3asymptotic-notations/